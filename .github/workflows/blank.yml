name: Build Exynos850 Android Kernel (GCC only, robust)

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    # env در سطح job تا بین steps پایدار بمونه
    env:
      ARCH: arm64
      SUBARCH: arm64
      # prefix برای ابزارهای کراس؛ برای apt نصب‌شده این مقدار کافی است
      CROSS_COMPILE: aarch64-linux-gnu-
      # OUT_DIR را به صورت مسیر workspace قرار می‌دهیم
      OUT_DIR: ${{ github.workspace }}/out
      KERNEL_SRC: kernel
      DEFCONFIG_REPO_PATH: config_repo/exlinux_defconfig
      MODULE_DIR: ${{ github.workspace }}/my_module

    steps:
      - name: Checkout kernel source (Exynos850 v4.19.120)
        uses: actions/checkout@v4
        with:
          repository: rsuntkOrgs/kernel_samsung_exynos850
          ref: v4.19.120
          path: kernel

      - name: Checkout defconfig repo (contains exlinux_defconfig)
        uses: actions/checkout@v4
        with:
          repository: rasolarmand114-tech/M
          path: config_repo

      - name: Install build dependencies (GCC toolchain, no clang)
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            build-essential bc bison flex libssl-dev libelf-dev dwarves wget xz-utils \
            gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu

      - name: Prepare OUT_DIR and copy exlinux_defconfig
        run: |
          echo "OUT_DIR=${OUT_DIR}"
          mkdir -p "${OUT_DIR}"
          if [ -f "${{ env.DEFCONFIG_REPO_PATH }}" ]; then
            cp "${{ env.DEFCONFIG_REPO_PATH }}" "${OUT_DIR}/.config"
            echo "Copied defconfig to ${OUT_DIR}/.config"
          else
            echo "ERROR: defconfig not found at ${DEFCONFIG_REPO_PATH}"
            ls -la config_repo || true
            exit 1
          fi
          ls -la "${OUT_DIR}" || true

      - name: Toolchain sanity check
        run: |
          echo "CROSS_COMPILE=${CROSS_COMPILE}"
          which ${CROSS_COMPILE}gcc || true
          ${CROSS_COMPILE}gcc --version || true
          ${CROSS_COMPILE}as --version || true
          ${CROSS_COMPILE}ld --version || true

      - name: Build kernel (GCC only, forced overrides)
        run: |
          set -euo pipefail
          export ARCH=arm64
          export CROSS_COMPILE=${CROSS_COMPILE}
          export CC=${CROSS_COMPILE}gcc
          export AS=${CROSS_COMPILE}as
          export LD=${CROSS_COMPILE}ld
          export AR=${CROSS_COMPILE}ar
          export NM=${CROSS_COMPILE}nm
          export OBJCOPY=${CROSS_COMPILE}objcopy
          export OBJDUMP=${CROSS_COMPILE}objdump
          export STRIP=${CROSS_COMPILE}strip
          # Force disable LLVM usage in kernel Makefiles
          export LLVM=0
          echo "Building kernel using ${CC}"
          # Parallel build; change -j1 V=1 for debugging if needed
          make -C "${KERNEL_SRC}" O="${OUT_DIR}" \
            ARCH=arm64 \
            CROSS_COMPILE="${CROSS_COMPILE}" \
            CC="${CC}" AS="${AS}" LD="${LD}" AR="${AR}" NM="${NM}" \
            OBJCOPY="${OBJCOPY}" OBJDUMP="${OBJDUMP}" STRIP="${STRIP}" \
            LLVM=0 -j$(nproc)

      - name: On-failure: rerun verbose single-job for diagnostics
        if: failure()
        run: |
          echo "Build failed — rerunning single-job verbose to capture exact invocation..."
          set +e
          export ARCH=arm64
          export CROSS_COMPILE=${CROSS_COMPILE}
          export CC=${CROSS_COMPILE}gcc
          # verbose single-threaded run (captures exact commands)
          make -C "${KERNEL_SRC}" O="${OUT_DIR}" ARCH=arm64 CROSS_COMPILE="${CROSS_COMPILE}" CC="${CC}" V=1 -j1 || true
          echo "==== tail of kernel build log (if present) ===="
          # if kernel writes log to a file, show it; otherwise show last lines of OUT_DIR
          if [ -f "${OUT_DIR}/build.log" ]; then
            tail -n 400 "${OUT_DIR}/build.log" || true
          else
            find "${OUT_DIR}" -maxdepth 2 -type f -name '*.o' -print -quit || true
            # try to show last lines of the last make output in runner log (best-effort)
          fi

      - name: Build custom module (if exists)
        run: |
          if [ -d "${{ env.MODULE_DIR }}" ]; then
            echo "Building modules in ${MODULE_DIR}..."
            make -C "${KERNEL_SRC}" O="${OUT_DIR}" M="${MODULE_DIR}" \
              ARCH=arm64 CROSS_COMPILE="${CROSS_COMPILE}" CC="${CROSS_COMPILE}gcc" modules || true
          else
            echo "No module directory at ${MODULE_DIR}; skipping module build."
          fi

      - name: Collect artifacts
        run: |
          mkdir -p artifacts
          # kernel Image (common path for arm64)
          if [ -f "${OUT_DIR}/arch/arm64/boot/Image" ]; then
            cp -v "${OUT_DIR}/arch/arm64/boot/Image" artifacts/ || true
          fi
          # optionally Image.gz or zImage
          if [ -f "${OUT_DIR}/arch/arm64/boot/Image.gz" ]; then
            cp -v "${OUT_DIR}/arch/arm64/boot/Image.gz" artifacts/ || true
          fi
          # DTBs if produced
          if [ -d "${OUT_DIR}/arch/arm64/boot/dts" ]; then
            cp -rv "${OUT_DIR}/arch/arm64/boot/dts" artifacts/dts || true
          fi
          # System.map and .config for debugging
          cp -v "${OUT_DIR}/System.map" artifacts/ 2>/dev/null || true
          cp -v "${OUT_DIR}/.config" artifacts/ 2>/dev/null || true
          # user modules
          if compgen -G "${{ env.MODULE_DIR }}/*.ko" > /dev/null 2>&1; then
            cp -v "${{ env.MODULE_DIR }}"/*.ko artifacts/ || true
          fi
          echo "Artifacts:"
          ls -la artifacts || true

      - name: Upload artifacts (kernel + modules)
        uses: actions/upload-artifact@v4
        with:
          name: exynos850-kernel-gcc
          path: artifacts/**
