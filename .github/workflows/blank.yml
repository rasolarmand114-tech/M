name: Kernel Build

on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    env:
      ARCH: arm64
      CROSS_COMPILE: aarch64-linux-gnu-
      OUT_DIR: out

    steps:
      # 1) سورس کرنل
      - name: Checkout kernel source
        uses: actions/checkout@v4
        with:
          repository: rsuntkOrgs/kernel_samsung_exynos850
          ref: v4.19.120
          path: kernel

      # 2) ریپو defconfig
      - name: Checkout defconfig
        uses: actions/checkout@v4
        with:
          repository: rasolarmand114-tech/M
          path: config_repo

      # 3) نصب وابستگی‌ها (فقط GCC)
      - name: Install build dependencies
        run: |
          sudo apt update
          sudo apt install -y \
            build-essential bc bison flex \
            libssl-dev libelf-dev dwarves \
            gcc-aarch64-linux-gnu \
            binutils-aarch64-linux-gnu

      # 4) آماده‌سازی out و کپی defconfig
      - name: Prepare build directory
        run: |
          mkdir -p $OUT_DIR
          cp config_repo/exlinux_defconfig $OUT_DIR/.config

      # 5) چک تول‌چین
      - name: Toolchain check
        run: |
          which ${CROSS_COMPILE}gcc
          ${CROSS_COMPILE}gcc --version

      # 6) بیلد کرنل (GCC only)
      - name: Build kernel
        run: |
          make -C kernel \
            O=$OUT_DIR \
            ARCH=arm64 \
            CROSS_COMPILE=$CROSS_COMPILE \
            CC=${CROSS_COMPILE}gcc \
            LLVM=0 \
            -j$(nproc)

      # 7) آپلود خروجی
      - name: Upload kernel image
        uses: actions/upload-artifact@v4
        with:
          name: exynos850-kernel
          path: |
            out/arch/arm64/boot/Image
            out/arch/arm64/boot/Image.gz
      - name: Install build dependencies (GCC toolchain, no clang)
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            build-essential bc bison flex libssl-dev libelf-dev dwarves wget xz-utils \
            gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu

      - name: Prepare OUT_DIR and copy exlinux_defconfig
        run: |
          echo "OUT_DIR=${OUT_DIR}"
          mkdir -p "${OUT_DIR}"
          if [ -f "${{ env.DEFCONFIG_REPO_PATH }}" ]; then
            cp "${{ env.DEFCONFIG_REPO_PATH }}" "${OUT_DIR}/.config"
            echo "Copied defconfig to ${OUT_DIR}/.config"
          else
            echo "ERROR: defconfig not found at ${DEFCONFIG_REPO_PATH}"
            ls -la config_repo || true
            exit 1
          fi
          ls -la "${OUT_DIR}" || true

      - name: Toolchain sanity check
        run: |
          echo "CROSS_COMPILE=${CROSS_COMPILE}"
          which ${CROSS_COMPILE}gcc || true
          ${CROSS_COMPILE}gcc --version || true
          ${CROSS_COMPILE}as --version || true
          ${CROSS_COMPILE}ld --version || true

      - name: Build kernel (GCC only, forced overrides)
        run: |
          set -euo pipefail
          export ARCH=arm64
          export CROSS_COMPILE=${CROSS_COMPILE}
          export CC=${CROSS_COMPILE}gcc
          export AS=${CROSS_COMPILE}as
          export LD=${CROSS_COMPILE}ld
          export AR=${CROSS_COMPILE}ar
          export NM=${CROSS_COMPILE}nm
          export OBJCOPY=${CROSS_COMPILE}objcopy
          export OBJDUMP=${CROSS_COMPILE}objdump
          export STRIP=${CROSS_COMPILE}strip
          # Force disable LLVM usage in kernel Makefiles
          export LLVM=0
          echo "Building kernel using ${CC}"
          # Parallel build; change -j1 V=1 for debugging if needed
          make -C "${KERNEL_SRC}" O="${OUT_DIR}" \
            ARCH=arm64 \
            CROSS_COMPILE="${CROSS_COMPILE}" \
            CC="${CC}" AS="${AS}" LD="${LD}" AR="${AR}" NM="${NM}" \
            OBJCOPY="${OBJCOPY}" OBJDUMP="${OBJDUMP}" STRIP="${STRIP}" \
            LLVM=0 -j$(nproc)

      - name: On-failure: rerun verbose single-job for diagnostics
        if: failure()
        run: |
          echo "Build failed — rerunning single-job verbose to capture exact invocation..."
          set +e
          export ARCH=arm64
          export CROSS_COMPILE=${CROSS_COMPILE}
          export CC=${CROSS_COMPILE}gcc
          # verbose single-threaded run (captures exact commands)
          make -C "${KERNEL_SRC}" O="${OUT_DIR}" ARCH=arm64 CROSS_COMPILE="${CROSS_COMPILE}" CC="${CC}" V=1 -j1 || true
          echo "==== tail of kernel build log (if present) ===="
          # if kernel writes log to a file, show it; otherwise show last lines of OUT_DIR
          if [ -f "${OUT_DIR}/build.log" ]; then
            tail -n 400 "${OUT_DIR}/build.log" || true
          else
            find "${OUT_DIR}" -maxdepth 2 -type f -name '*.o' -print -quit || true
            # try to show last lines of the last make output in runner log (best-effort)
          fi

      - name: Build custom module (if exists)
        run: |
          if [ -d "${{ env.MODULE_DIR }}" ]; then
            echo "Building modules in ${MODULE_DIR}..."
            make -C "${KERNEL_SRC}" O="${OUT_DIR}" M="${MODULE_DIR}" \
              ARCH=arm64 CROSS_COMPILE="${CROSS_COMPILE}" CC="${CROSS_COMPILE}gcc" modules || true
          else
            echo "No module directory at ${MODULE_DIR}; skipping module build."
          fi

      - name: Collect artifacts
        run: |
          mkdir -p artifacts
          # kernel Image (common path for arm64)
          if [ -f "${OUT_DIR}/arch/arm64/boot/Image" ]; then
            cp -v "${OUT_DIR}/arch/arm64/boot/Image" artifacts/ || true
          fi
          # optionally Image.gz or zImage
          if [ -f "${OUT_DIR}/arch/arm64/boot/Image.gz" ]; then
            cp -v "${OUT_DIR}/arch/arm64/boot/Image.gz" artifacts/ || true
          fi
          # DTBs if produced
          if [ -d "${OUT_DIR}/arch/arm64/boot/dts" ]; then
            cp -rv "${OUT_DIR}/arch/arm64/boot/dts" artifacts/dts || true
          fi
          # System.map and .config for debugging
          cp -v "${OUT_DIR}/System.map" artifacts/ 2>/dev/null || true
          cp -v "${OUT_DIR}/.config" artifacts/ 2>/dev/null || true
          # user modules
          if compgen -G "${{ env.MODULE_DIR }}/*.ko" > /dev/null 2>&1; then
            cp -v "${{ env.MODULE_DIR }}"/*.ko artifacts/ || true
          fi
          echo "Artifacts:"
          ls -la artifacts || true

      - name: Upload artifacts (kernel + modules)
        uses: actions/upload-artifact@v4
        with:
          name: exynos850-kernel-gcc
          path: artifacts/**
